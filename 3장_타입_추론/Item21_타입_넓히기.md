## 📕 오늘 읽은 내용, 이런 식으로 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.01.27

**오늘 읽은 범위** : 21. 타입 넓히기

# Item 21. 타입 넓히기

아이템 7에서 설명한 것처럼 런타임에 모든 변수는 유일한 값을 가진다.   
그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 '가능한' 값들의 집합인 타입을 가진다.   
상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다.   
이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻이다.   
넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있을 것이다.   
   
 백터를 다루는 라이브러리를 작성한다고 가정해보자.   
 3D 백터에 대한 타입과 그 요소들의 값을 얻는 함수를 작성한다.   
    
 ```ts
interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
 ```
 
 Vector3 함수를 사용한 다음 코드는 런타임에 오류 없이 실행되지만, 편집기에서는 오류가 표시된다.   
 ```ts
const x = 'x'; 
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);  
      // ~ 'string' 형식의 인수는 ' "x" | "y" | "z" '
      // 형식의 매개변수에 할당될 수 없습니다.
 ```
 실행은 잘 되지만 편집기에서는 오류가 발생한다.   
    
getComponent 함수는 두 번째 매개변수에 "x" | "y" | "z" 타입을 기대했지만, x의 타입은 할당 시점에 넓히기가 동작해서 string으로 추론되었습니다.   
string 타입은 | "x" | "y" | "z" 타입에 할당이 불가능하므로 오류가 된 것이다.   
   
타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 상당히 모호하다.   
>다음 코드를 예로 들어 보자.
```ts
const mixed = ['x', 1];
```

`mixed`의 타입이 어떻게 추론되는지 살펴보자.   
>다음은 `mixed`의 타입이 될 수 있는 후보들이다.
- ('x' | 1)[]
- ['x', 1]
- [string, number]
- readonly [string, number]
- (string|number)[]
- readonly (string|number)[]
- [any, any]
- any[]

정보가 충분하지 않다면 mixed가 어떤 타입으로 추론되어야 하는지 알 수 없다.   
그러므로 타입스크립트는 작성자의 의도를 추측한다.(이 경우에는, (string|number)[]으로 추측합니다)    
그러나 타입스크립트가 아무리 영리하더라도 사람의 마음까지 읽을 수는 없고 따라서 추측한 답이 항상 옳을 수도 없다.   
   
처음의 예제에서 타입스크립트는 다음 예제와 같은 코드를 예상했기 때문에 x의 타입을 string으로 추론했다.   
```ts
let x = 'x';
x = 'a';
x = 'Four score and seven years aog...';
```

> 자바스크립트에서는 다음처럼 작성해도 유효하다.   
```ts
let x = 'x';
x = /x|y|z/;
x = ['x', 'y', 'z'];
```

타입스크립트는 x의 타입을 string으로 추론할 때, 명확성과 유연성 사이의 균형을 유지하려고 한다.   
일반적인 규칙은 변수가 선언된 후로는 타입이 바뀌지 않아야 하므로, string|RegExp나 string|string[]이나 any보다는 string을 사용하는 게 낫다.   



---

타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다.   
타입스크립트의 기본 동작을 재정의하는 세 가지 방법이 있다.   
>첫 번째, 명시적 타입 구문을 제공하는 것이다.   
   
```ts
const v: { x: 1|3|5} = {
  x: 1,
}; // 타입이 { x: 1|3|5; }
```
>두 번째, 타입 체커에 추가적인 문맥을 제겅하는 것이다. (예를 들어, 함수의 매개변수로 값을 전달)   (아이템 26에서 자세히 다룸)    

<br>

>세 번째, const 단언문을 사용하는 것이다.   
const 단언문과 변수 선언에 쓰이는 let이나 const와 혼동해서는 안 된다.   
const 단언문은 온전히 타입 공간의 기법이다.   
다음 예제를 통해 각 변수에 추론된 타입의 차이점을 살펴보자.   
```ts


interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const v1 = {
  x: 1,
  y: 2,
};  // Type is { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
};  // Type is { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const;  // Type is { readonly x: 1; readonly y: 2; }
```
값 뒤에 as const를 작성하면, 타입스크립트는 최대한 좁은 타입으로 추론한다.   
v3에는 넓히기가 동작하지 않았다.   
v3이 진짜 상수라면, 주석에 보이는 추론된 타입이 실제로 원하는 형태일 것이다.   
또한 배열을 튜플 타입으로 추론할 때에도 as const를 사용할 수 있다.   
```ts
const a1 = [1, 2, 3];           // 타입이 number[]
const a2 = [1, 2, 3] as const;  // 타입이 readonly [1, 2, 3]
```
넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 const 단언문을 추가하는 것을 고려해야 한다.   
단언문으로 인해 추론이 어떻게 변화하는지 편집기에서 주기적으로 타입을 살펴보기 바란다.   
   
 <br>
 
 ## 요약
 
 - 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
 - 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 한다.
